# Java基础总结

<!-- TOC -->

- [1. 面向对象编程](#一、面向对象编程)
  - [面向对象三大特性](#1.面向对象三大特性)
  - [方法重载和方法重写](#2.方法重载和方法重写)
  - [面向对象和面向过程](#3.面向对象和面向过程)
- [2. Java基础数据类型](#二、Java基础数据类型)
- [4. Java集合](#三、Java集合)
- [4. 创建线程](#四、创建线程)
- [5. ==和equals方法的区别?](#五、==和equals方法的区别)
- [6. 接口和抽象类的区别](#六、接口和抽象类的区别)
- [7. public、protected、private、默认修饰符](#七、public、protected、private、默认修饰符)

<!-- /TOC -->

## 一、面向对象编程

### 1.面向对象三大特性

1. 继承： 可以使用现有类的功能，并在不重新编码原有类的情况下对其进行扩展，继承和组合的方式

2. 多态：允许将父对象设置成一个或多个其子对象相等的技术，赋值之后，父对象就可以根据当前赋值给他的子对象的特性运作，也就是允许将子类类型的指针赋值给他的父类类型的指针

3. 封装：将客观事物的特性封装成抽象的类，并且可以将自己的数据和方法隐藏起来只让可信的类或对象操作，通过访问修饰符进行隐藏和访问控制

### 2.方法重载和方法重写

多态可分为运行时多态和编译时多态，分别指方法重写又叫覆写和方法重载

+ 方法重写发生在父子类之间，子类通过继承父类的方法进行重写

+ 方法重载发生在当前类之间，通过方法参数个数、类型不同对同名方法进行重载，需要注意的是返回值类型不同不是方法重载

### 3.面向对象和面向过程

+ 面向对象的编程方式使得每一个类都只做一件事，而面向过程则会给一个类添加越来越多的功能
+ 面向对象的编程方式可以降低类与类之间的耦合性，通过面向对象的封装、继承和多态三大特性大大的提升程序的可维护性、可复用性、可扩展性和灵活性
+ 面向过程是只做一件事，在这件事做得过程中的步骤、判断都在一个类中进行，而面向对象则是将不同的步骤交由不同的类去实现，最终通过组合的方式实现一整个任务，并且还可以产生很多可复用、可扩展的类以供后面使用，而面向过程就只能做一件事，如果需要修改就全部都要改

## 二、Java基础数据类型

  四种整形：byte、short、int、long 两种浮点数：float、double 一个字符型：char 一个布尔值：boolean

## 三、Java集合

### 1.List
  
列表，有序，按存入的顺序排列
  
+ ArrayList
+ LinkedList
+ Vector

### 2.Set

一种不包含重复元素的无序集合

+ TreeSet
+ HashSet

### 3.Map

一种Key-Value集合，不存在重复的key，每个key最多映射到一个value上

+ TreeMap
+ HashMap
+ HashTable

## 四、创建线程

### 1.继承Thread类

```java
public class ThreadTest extends Thread {
  @override
  public void run(){

  }
}
```

### 2.实现Runnable接口

```java
public class ThreadTest implements Runnable {
  @override
  public void run(){

  }
}
```

## 五、==和equals方法的区别

### 1.==的使用

比较两个对象是否相等，比较基本数据类型时是比较两个基本数据类型的值是否一致，在比较引用类型时是比较两个对象的引用类型的内存地址是否一致

### 2.equals方法的使用

equals方法为Object对象的方法，默认为使用==比较两个对象是否相等
```java
public boolean equals(Object obj) {
    return (this == obj);
}
```
但是可以在自定义对象中重写该方法判断两个对象是否相等，例如String对象
```java
public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```

## 六、接口和抽象类的区别

1. 接口和抽象类都不能直接实例化。抽象类实例化时需要指向一个实现了他所有**抽象方法**的子类对象，接口实例化时需要指向一个实现了该接口所有方法的子类对象
2. 接口中的方法默认是public的，在1.8之后接口中可以声明default方法，抽象类中的方法1.8之前默认是protected的，1.8是default的。同时接口中的方法都是抽象方法不能有实现(1.8中default方法和static方法除外)，抽象类至少有一个抽象方法，抽象方法使用abstract修饰，没有实现
3. 抽象类中的抽象方法必须被子类全部实现，如果没有全部实现，则需要将子类声明为抽象类。接口中的方法在子类中同样需要全部实现，如果没有全部实现，则需要将子类声明为抽象类
4. 抽象类还是一个类，因此主要是用来抽象类别，而接口更注重方法接口功能。当主要关注事物的本质的时候，选择抽象类，而更关注操作实现的时候，选择接口。抽象类只能被继承一个，而接口可以实现多重继承即一个接口可以继承多个接口，而一个类只能继承一个抽象类，但是可以实现多个接口
5. 抽象类中抽象方法修饰符可以是public、protected和default的，不能为private因为需要继承，接口中的方法在1.8的时候修饰符可以是public、default的。接口中**成员变量默认为 static final 的**，抽象类中则没有限制
6. 抽象类可以没有抽象方法，但是有抽象方法的一定是抽象类
7. 接口主要是对类的行为进行约束，对不同的类强制约束有相同的行为，但是没有对行为的实现做限制，而抽象类主要是进行代码复用，当不同的类拥有某些类似的行为时，并且其中一部分实现方式一致时，可以将这些类派生为一个抽象类，在抽象类中实现方式一致的行为，从而达到代码复用的目的，而其他个性化的行为则可以使用抽象方法声明出来交由子类实现，而正是个性化的部分没有实现，因此抽象类不允许被实例化

## 七、public、protected、private、默认修饰符

访问修饰符主要用来修饰方法、类、成员变量，其中修饰类只能使用public和默认(即不加修饰符)

### 1. public 修饰符

访问权限最宽松，所有其他的类都可以访问到

### 2. protected 修饰符

访问权限在当前类和当前类的子类之间，子类可以重写方法或者覆盖变量

### 3. private 修饰符

访问权限仅仅在当前类中，其他类都不可以访问，但是与内部类之间可以相互访问对方的private修饰符修饰的方法、成员变量

### 4. 默认修饰符(即不加修饰符)

不加修饰符的情况下只能访问同一个包下面的类、方法、成员变量

## 八、static、final修饰符

### 1.static修饰符

可修饰变量、方法、代码块和静态内部类

+ 类中的静态变量属于类对象，该类的所有实例对象都可以访问该变量，不能修饰局部变量
+ 静态变量只有一份，在类代码执行，编译器(类初始化)的时候优先执行静态代码的加载，并且初始化之后可以修改
+ static修饰的属性强调只有一个
+ 类的static修饰的方法只能访问其他被static修饰的成员，不可以访问非static成员
+ static修饰的属性不会发生继承，只能被当前类声明使用
+ static方法中不可以使用this关键字，static修饰的代码块只在类被加载的时候执行一次

### 2.final修饰符

可修饰变量、方法和类

+ 被final修饰的属性的初始化可以在编译期，也可以在运行期，初始化之后不可改变
+ 被final修饰的变量，基本数据类型在初始化之后不可改变，对象引用在初始化之后不可再指向另一个对象，相当于一个常量
+ final修饰的方法表示该方法不会被子类重写
+ final修饰的类表示该被不能被继承
+ final修饰的类属性和变量属性必须要进行显示初始化赋值
