# Java基础总结

<!-- TOC -->

- [1. 面向对象编程](#一、面向对象编程)
  - [面向对象三大特性](#1.面向对象三大特性)
  - [方法重载和方法重写](#2.方法重载和方法重写)
  - [面向对象和面向过程](#3.面向对象和面向过程)
- [2. Java基础数据类型](#二、Java基础数据类型)
- [4. Java集合](#三、Java集合)
- [4. 创建线程](#四、创建线程)
- [5. ==和equals方法的区别?](#五、==和equals方法的区别)
- [6. 接口和抽象类的区别](#六、接口和抽象类的区别)
- [7. public、protected、private、默认修饰符](#七、public、protected、private、默认修饰符)
- [8. static、final修饰符](#八、static、final修饰符)
- [9. Comparable接口和Comparator接口的区别](九、Comparable接口和Comparator接口的区别)
- [10. volatile、synchronized关键字](十、volatile、synchronized关键字)

<!-- /TOC -->

## 一、面向对象编程

### 1.面向对象三大特性

1. 继承： 可以使用现有类的功能，并在不重新编码原有类的情况下对其进行扩展，继承和组合的方式

2. 多态：允许将父对象设置成一个或多个其子对象相等的技术，赋值之后，父对象就可以根据当前赋值给他的子对象的特性运作，也就是允许将子类类型的指针赋值给他的父类类型的指针

3. 封装：将客观事物的特性封装成抽象的类，并且可以将自己的数据和方法隐藏起来只让可信的类或对象操作，通过访问修饰符进行隐藏和访问控制

### 2.方法重载和方法重写

多态可分为运行时多态和编译时多态，分别指方法重写又叫覆写和方法重载

+ 方法重写发生在父子类之间，子类通过继承父类的方法进行重写

+ 方法重载发生在当前类之间，通过方法参数个数、类型不同对同名方法进行重载，需要注意的是返回值类型不同不是方法重载

### 3.面向对象和面向过程

+ 面向对象的编程方式使得每一个类都只做一件事，而面向过程则会给一个类添加越来越多的功能
+ 面向对象的编程方式可以降低类与类之间的耦合性，通过面向对象的封装、继承和多态三大特性大大的提升程序的可维护性、可复用性、可扩展性和灵活性
+ 面向过程是只做一件事，在这件事做得过程中的步骤、判断都在一个类中进行，而面向对象则是将不同的步骤交由不同的类去实现，最终通过组合的方式实现一整个任务，并且还可以产生很多可复用、可扩展的类以供后面使用，而面向过程就只能做一件事，如果需要修改就全部都要改

## 二、Java基础数据类型

  四种整形：byte、short、int、long 两种浮点数：float、double 一个字符型：char 一个布尔值：boolean

## 三、Java集合

### 1.List

列表，有序，按存入的顺序排列

+ ArrayList
+ LinkedList
+ Vector

### 2.Set

一种不包含重复元素的无序集合

+ TreeSet
+ HashSet

### 3.Map

一种Key-Value集合，不存在重复的key，每个key最多映射到一个value上

+ TreeMap
+ HashMap
+ HashTable

## 四、创建线程

### 1.继承Thread类

```java
public class ThreadTest extends Thread {
  @override
  public void run(){

  }
}
```

### 2.实现Runnable接口

```java
public class ThreadTest implements Runnable {
  @override
  public void run(){

  }
}
```

## 五、==和equals方法的区别

### 1.==的使用

比较两个对象是否相等，比较基本数据类型时是比较两个基本数据类型的值是否一致，在比较引用类型时是比较两个对象的引用类型的内存地址是否一致

### 2.equals方法的使用

equals方法为Object对象的方法，默认为使用==比较两个对象是否相等
```java
public boolean equals(Object obj) {
    return (this == obj);
}
```
但是可以在自定义对象中重写该方法判断两个对象是否相等，例如String对象
```java
public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```

## 六、接口和抽象类的区别

1. 接口和抽象类都不能直接实例化。抽象类实例化时需要指向一个实现了他所有**抽象方法**的子类对象，接口实例化时需要指向一个实现了该接口所有方法的子类对象
2. 接口中的方法默认是public的，在1.8之后接口中可以声明default方法，抽象类中的方法1.8之前默认是protected的，1.8是default的。同时接口中的方法都是抽象方法不能有实现(1.8中default方法和static方法除外)，抽象类至少有一个抽象方法，抽象方法使用abstract修饰，没有实现
3. 抽象类中的抽象方法必须被子类全部实现，如果没有全部实现，则需要将子类声明为抽象类。接口中的方法在子类中同样需要全部实现，如果没有全部实现，则需要将子类声明为抽象类
4. 抽象类还是一个类，因此主要是用来抽象类别，而接口更注重方法接口功能。当主要关注事物的本质的时候，选择抽象类，而更关注操作实现的时候，选择接口。抽象类只能被继承一个，而接口可以实现多重继承即一个接口可以继承多个接口，而一个类只能继承一个抽象类，但是可以实现多个接口
5. 抽象类中抽象方法修饰符可以是public、protected和default的，不能为private因为需要继承，接口中的方法在1.8的时候修饰符可以是public、default的。接口中**成员变量默认为 static final 的**，抽象类中则没有限制
6. 抽象类可以没有抽象方法，但是有抽象方法的一定是抽象类
7. 接口主要是对类的行为进行约束，对不同的类强制约束有相同的行为，但是没有对行为的实现做限制，而抽象类主要是进行代码复用，当不同的类拥有某些类似的行为时，并且其中一部分实现方式一致时，可以将这些类派生为一个抽象类，在抽象类中实现方式一致的行为，从而达到代码复用的目的，而其他个性化的行为则可以使用抽象方法声明出来交由子类实现，而正是个性化的部分没有实现，因此抽象类不允许被实例化

## 七、public、protected、private、默认修饰符

访问修饰符主要用来修饰方法、类、成员变量，其中修饰类只能使用public和默认(即不加修饰符)

### 1. public 修饰符

访问权限最宽松，所有其他的类都可以访问到

### 2. protected 修饰符

访问权限在当前类和当前类的子类之间，子类可以重写方法或者覆盖变量

### 3. private 修饰符

访问权限仅仅在当前类中，其他类都不可以访问，但是与内部类之间可以相互访问对方的private修饰符修饰的方法、成员变量

### 4. 默认修饰符(即不加修饰符)

不加修饰符的情况下只能访问同一个包下面的类、方法、成员变量

## 八、static、final修饰符

### 1. static修饰符

可修饰变量、方法、代码块和静态内部类

+ 类中的静态变量属于类对象，该类的所有实例对象都可以访问该变量，不能修饰局部变量
+ 静态变量只有一份，在类代码执行，编译器(类初始化)的时候优先执行静态代码的加载，并且初始化之后可以修改
+ static修饰的属性强调只有一个
+ 类的static修饰的方法只能访问其他被static修饰的成员，不可以访问非static成员
+ static修饰的属性不会发生继承，只能被当前类声明使用
+ static方法中不可以使用this关键字，static修饰的代码块只在类被加载的时候执行一次

### 2. final修饰符

可修饰变量、方法和类

+ 被final修饰的属性的初始化可以在编译期，也可以在运行期，初始化之后不可改变
+ 被final修饰的变量，基本数据类型在初始化之后不可改变，对象引用在初始化之后不可再指向另一个对象，相当于一个常量
+ final修饰的方法表示该方法不会被子类重写
+ final修饰的类表示该被不能被继承
+ final修饰的类属性和变量属性必须要进行显示初始化赋值

## 九、Comparable接口和Comparator接口的区别

### 1. Comparable接口

+ Comparable接口是在java.lang包下
+ Comparable接口只有一个compareTo方法，该方法支持类似于equals方法比较两个对象的等同性，还支持执行顺序的比较，并且是泛型方法
+ 类实现了Comparable接口表示该类的实例具有内在的排序关系，即自然排序
+ 比较两个对象的时候，前一个对象小于、等于或大于指定的对象时，该方法分别返回一个负整数、零或者正整数
+ compareTo方法中的比较是顺序的比较，而不是等同性的比较。而compareTo方法的等同性测试，在通常情况下应该返回与equals方法同样的结果。即说明compareTo方法所施加的顺序关系与equals一致，否则则说明顺序关系和equals不一致
+ 在使用compareTo方法比较null时，应该抛出NullPointerException异常
+ 有序集合使用了由compareTo方法而不是equals方法所施加的等同性测试

### 2. Comparator接口

+ Comparator接口属于集合框架的一部分，在java.util包下
+ Comparator接口主要是用来在外部定制排序规则
+ Comparactor接口可以针对当前类生成多个定制排序类，通过comapre方法比较两个对象实例是否一致，而Comparable接口则只能实现一次
+ Comparactor接口的实现类可以作为排序策略参数传递给一些排序方法，如Collections.sort()、Arrays.sort(),或者一些有序接口如(SortedSet、SortedMap)
+ 使用Comparactor接口实现排序策略可以避免向原有类添加额外的代码

## 十、volatile、synchronized关键字

### 1. volatile关键字

+ volatile关键字保证了多个线程之间对变量操作的内存可见性以及禁止了指令重排
+ 在写一个volatile变量时，Java内存模型会将当前线程的内存副本中的变量值刷新到主内存当中
+ 在读一个volatile变量时，Java内存模型会将当前线程的内存副本中的变量值置为无效，重新读取主内存中该变量的值
+ 内存屏障提供了以下保证：
  - 重排序时不能将后面的指令重排序到内存屏障之前
  - 将当前CPU的缓存写入内存
  - 写入操作会引起其他CPU或其他内核无效化其缓存
+ JVM会在每个volatile变量的写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障
+ JVM会在每个volatile变量的读操作前插入LoadLoad屏障，在读操作之后插入LoadStore屏障
+ volatile变量只能保证可见性，主要用在符合以下两条规则的运算场景中：
   - 运算结果并不依赖变量的当前值，或者能够确保只有单一线程修改变量的值
   - 变量不需要与其他的状态变量共同参与不变约束

### 2. synchronized关键字

synchronized关键字主要是用来避免多线程死锁问题，类似的还有lock、condition、threadlocal、atomic包和cas

synchronized的用法：

synchronized主要是修饰在对象上面，其中分为以下几种情况

1. 修饰一个类，作用对象是这个类对象，属于**类对象锁**，作用范围为这个类的所有对象
2. 修饰在静态方法上，作用对象同样是这个**类对象**，作用范围同样是这个类的所有对象
3. 修饰在代码块，指向私有变量，作用对象是**当前对象**，作用范围为当前对象代码块的所有线程
4. 修饰在普通方法上，作用对象依旧是**当前对象**，作用范围也是访问当前对象代码块的所有线程

以下几点需要注意

- 在定义接口方法时不能使用synchronized关键字。
- 构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。
- synchronized 关键字不能被继承 。如果子类覆盖了父类的 被 synchronized 关键字修饰的方法，那么子类的该方法只要没有 synchronized 关键字，那么就默认没有同步，也就是说，不能继承父类的 synchronized。
- 应该尽量使用私有变量进行同步，这样可以避免其他代码锁定当前对象，相比起使用this引用避免了过度同步